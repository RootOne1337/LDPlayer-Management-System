# üìÖ WEEK 2 - –î–ï–¢–ê–õ–¨–ù–´–ô –ü–õ–ê–ù –†–ê–ë–û–¢

**–ü–µ—Ä–∏–æ–¥:** 18-22 –æ–∫—Ç—è–±—Ä—è 2025  
**–¶–µ–ª—å:** –ü–æ–¥–∫–ª—é—á–∏—Ç—å —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ + –¢–µ—Å—Ç—ã + –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥  
**Target Progress:** 50% ‚Üí 75%

---

## üéØ –ì–õ–ê–í–ù–´–ï –¶–ï–õ–ò –ù–ï–î–ï–õ–ò

1. **–ü–æ–¥–∫–ª—é—á–∏—Ç—å —Ö–æ—Ç—è –±—ã 1 real workstation** - –≤—ã–π—Ç–∏ –∏–∑ DEV —Ä–µ–∂–∏–º–∞
2. **–ù–∞–ø–∏—Å–∞—Ç—å 20+ automated tests** - –æ–±–µ—Å–ø–µ—á–∏—Ç—å –∫–∞—á–µ—Å—Ç–≤–æ
3. **–î–æ–±–∞–≤–∏—Ç—å –±–∞–∑–æ–≤—ã–π monitoring** - –≤–∏–¥–µ—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã
4. **–î–æ—Å—Ç–∏—á—å 75% system readiness** - –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ pre-production

---

## üìÜ DAY-BY-DAY BREAKDOWN

### üî¥ DAY 1: WinRM Setup (18 –æ–∫—Ç—è–±—Ä—è) - P0 CRITICAL

**–í—Ä–µ–º—è:** 4-6 —á–∞—Å–æ–≤  
**–¶–µ–ª—å:** –ù–∞—Å—Ç—Ä–æ–∏—Ç—å WinRM –Ω–∞ 1 —Ç–µ—Å—Ç–æ–≤–æ–π –º–∞—à–∏–Ω–µ

#### –ó–∞–¥–∞—á–∏:

**1.1 –í—ã–±—Ä–∞—Ç—å —Ç–µ—Å—Ç–æ–≤—É—é –º–∞—à–∏–Ω—É** (30 –º–∏–Ω)
- [ ] –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å IP address (–Ω–∞–ø—Ä–∏–º–µ—Ä: 192.168.1.101)
- [ ] –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ LDPlayer —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
- [ ] –£–±–µ–¥–∏—Ç—å—Å—è –≤ —Å–µ—Ç–µ–≤–æ–π –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏
- [ ] –ó–∞–ø–æ–º–Ω–∏—Ç—å credentials (admin/password)

**1.2 –ù–∞—Å—Ç—Ä–æ–∏—Ç—å WinRM –Ω–∞ workstation** (1 —á–∞—Å)
```powershell
# –ù–∞ —É–¥–∞–ª–µ–Ω–Ω–æ–π –º–∞—à–∏–Ω–µ (192.168.1.101):

# 1. Enable WinRM
winrm quickconfig
# –û—Ç–≤–µ—Ç–∏—Ç—å "Y" –Ω–∞ –≤—Å–µ –≤–æ–ø—Ä–æ—Å—ã

# 2. Enable PowerShell Remoting
Enable-PSRemoting -Force

# 3. –î–æ–±–∞–≤–∏—Ç—å trusted hosts (–Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ)
Set-Item WSMan:\localhost\Client\TrustedHosts "192.168.1.101" -Force

# 4. –í–∫–ª—é—á–∏—Ç—å Basic auth (–¥–ª—è PyWinRM)
winrm set winrm/config/service/auth '@{Basic="true"}'
winrm set winrm/config/service '@{AllowUnencrypted="true"}'

# 5. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å
winrm get winrm/config

# 6. –û—Ç–∫—Ä—ã—Ç—å firewall (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
netsh advfirewall firewall add rule name="WinRM-HTTP" dir=in action=allow protocol=TCP localport=5985
```

**Verification:**
```powershell
# –° –ª–æ–∫–∞–ª—å–Ω–æ–π –º–∞—à–∏–Ω—ã:
Test-WSMan -ComputerName 192.168.1.101
```

**1.3 –°–æ–∑–¥–∞—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–π —Å–∫—Ä–∏–ø—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è** (1 —á–∞—Å)
```python
# Server/test_winrm_connection.py

from pywinrm.protocol import Protocol
import sys
import json

def test_winrm_connection(host, username, password):
    """Test WinRM connection to remote workstation"""
    print(f"\nüîç Testing connection to {host}...")
    
    try:
        # Create WinRM protocol
        endpoint = f'http://{host}:5985/wsman'
        p = Protocol(
            endpoint=endpoint,
            transport='plaintext',
            username=username,
            password=password,
            server_cert_validation='ignore'
        )
        
        # Test 1: Run simple command
        print("Test 1: Running 'ipconfig'...")
        result = p.run_cmd('ipconfig')
        if result.status_code == 0:
            print("‚úÖ Command executed successfully")
            print(result.std_out.decode('utf-8')[:200])
        else:
            print(f"‚ùå Command failed: {result.std_err}")
            return False
        
        # Test 2: Check LDPlayer installation
        print("\nTest 2: Checking LDPlayer installation...")
        ldplayer_check = '''
        $ldpath = "C:\\Program Files\\LDPlayer\\LDPlayer4.0"
        if (Test-Path $ldpath) {
            Write-Output "LDPlayer found at: $ldpath"
            Get-ChildItem $ldpath -Filter "dnconsole.exe" | Select-Object FullName
        } else {
            Write-Output "LDPlayer not found"
        }
        '''
        result = p.run_ps(ldplayer_check)
        if result.status_code == 0:
            output = result.std_out.decode('utf-8')
            print(output)
            if "LDPlayer found" in output:
                print("‚úÖ LDPlayer installation detected")
            else:
                print("‚ö†Ô∏è LDPlayer not found - check installation path")
        
        # Test 3: List emulators
        print("\nTest 3: Listing emulators...")
        list_cmd = '''
        $ldconsole = "C:\\Program Files\\LDPlayer\\LDPlayer4.0\\dnconsole.exe"
        if (Test-Path $ldconsole) {
            & $ldconsole list
        } else {
            Write-Output "dnconsole.exe not found"
        }
        '''
        result = p.run_ps(list_cmd)
        if result.status_code == 0:
            output = result.std_out.decode('utf-8')
            print(output)
            print("‚úÖ Emulator list retrieved")
        
        print(f"\nüéâ All tests passed! WinRM connection to {host} is working!")
        return True
        
    except Exception as e:
        print(f"\n‚ùå Connection failed: {type(e).__name__}: {str(e)}")
        return False

if __name__ == "__main__":
    # Configuration
    HOST = "192.168.1.101"
    USERNAME = "admin"
    PASSWORD = "your_password"
    
    # Test connection
    success = test_winrm_connection(HOST, USERNAME, PASSWORD)
    sys.exit(0 if success else 1)
```

**Run test:**
```powershell
cd Server
python test_winrm_connection.py
```

**Expected Output:**
```
üîç Testing connection to 192.168.1.101...
Test 1: Running 'ipconfig'...
‚úÖ Command executed successfully
Windows IP Configuration...

Test 2: Checking LDPlayer installation...
LDPlayer found at: C:\Program Files\LDPlayer\LDPlayer4.0
‚úÖ LDPlayer installation detected

Test 3: Listing emulators...
0,Android-Game-1,running,0,0
1,Android-Game-2,stopped,0,0
‚úÖ Emulator list retrieved

üéâ All tests passed! WinRM connection to 192.168.1.101 is working!
```

**1.4 –û–±–Ω–æ–≤–∏—Ç—å config.json —Å real workstation** (30 –º–∏–Ω)
```json
{
  "workstations": [
    {
      "id": "ws-production-1",
      "name": "Production Workstation 1",
      "host": "192.168.1.101",
      "protocol": "winrm",
      "ldplayer_path": "C:\\Program Files\\LDPlayer\\LDPlayer4.0",
      "auth": {
        "username": "admin",
        "password": "ENCRYPTED_BY_FERNET"
      },
      "enabled": true
    }
  ]
}
```

**Encrypt password:**
```python
from src.core.security import SecurityManager
security = SecurityManager()
encrypted = security.encrypt_password("your_password")
print(encrypted)  # –î–æ–±–∞–≤–∏—Ç—å –≤ config.json
```

**1.5 –ó–∞–ø—É—Å—Ç–∏—Ç—å server –ë–ï–ó DEV_MODE** (30 –º–∏–Ω)
```powershell
cd Server
# –ë–ï–ó DEV_MODE - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ä–µ–∞–ª—å–Ω—ã–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
python run_server_stable.py
```

**Check logs:**
```
[INFO] üöÄ Starting LDPlayer Management Server...
[INFO] üîó Connecting to workstation: Production Workstation 1 (192.168.1.101)...
[INFO] ‚úÖ Connected via WinRM
[INFO] üéÆ Detecting emulators...
[INFO] ‚úÖ Found 2 emulators: [Android-Game-1, Android-Game-2]
[INFO] üåê Server started on https://localhost:8000
```

**1.6 –ü—Ä–æ–≤–µ—Ä–∏—Ç—å UI** (30 –º–∏–Ω)
```
1. –û—Ç–∫—Ä—ã—Ç—å http://localhost:3000
2. Login: admin / admin123
3. Dashboard –¥–æ–ª–∂–µ–Ω –ø–æ–∫–∞–∑–∞—Ç—å:
   ‚úÖ 1 online workstation (–≤–º–µ—Å—Ç–æ mock 4)
   ‚úÖ –†–µ–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–º—É–ª—è—Ç–æ—Ä–æ–≤
4. –ü–µ—Ä–µ–π—Ç–∏ –≤ Emulators
   ‚úÖ –í–∏–¥–µ—Ç—å —Ä–µ–∞–ª—å–Ω—ã–µ —ç–º—É–ª—è—Ç–æ—Ä—ã —Å workstation
5. –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å Start/Stop –Ω–∞ —Ä–µ–∞–ª—å–Ω–æ–º —ç–º—É–ª—è—Ç–æ—Ä–µ
   ‚úÖ –≠–º—É–ª—è—Ç–æ—Ä –¥–æ–ª–∂–µ–Ω –∑–∞–ø—É—Å—Ç–∏—Ç—å—Å—è/–æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è
```

**Success Criteria Day 1:**
- ‚úÖ WinRM –Ω–∞—Å—Ç—Ä–æ–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç
- ‚úÖ Server –ø–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –∫ workstation
- ‚úÖ –û–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ—Ç LDPlayer –∏ —ç–º—É–ª—è—Ç–æ—Ä—ã
- ‚úÖ UI –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
- ‚úÖ Start/Stop —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ —Ä–µ–∞–ª—å–Ω–æ–º –∂–µ–ª–µ–∑–µ

---

### üî¥ DAY 2: Production Mode Refinement (19 –æ–∫—Ç—è–±—Ä—è) - P0

**–í—Ä–µ–º—è:** 4 —á–∞—Å–∞  
**–¶–µ–ª—å:** –°—Ç–∞–±–∏–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å real workstation

#### –ó–∞–¥–∞—á–∏:

**2.1 –î–æ–±–∞–≤–∏—Ç—å error handling –¥–ª—è WinRM** (1.5 —á–∞—Å–∞)
```python
# src/remote/workstation.py

from tenacity import retry, stop_after_attempt, wait_exponential
import logging

class Workstation:
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        reraise=True
    )
    def connect(self):
        """Connect to workstation with retry logic"""
        try:
            self.logger.info(f"üîó Connecting to {self.name} ({self.host})...")
            self.protocol = Protocol(
                endpoint=f'http://{self.host}:5985/wsman',
                transport='plaintext',
                username=self.auth['username'],
                password=self.auth['password']
            )
            # Test connection
            result = self.protocol.run_cmd('echo test')
            if result.status_code != 0:
                raise ConnectionError(f"Failed to connect: {result.std_err}")
            
            self.logger.info(f"‚úÖ Connected to {self.name}")
            self.connected = True
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Connection failed: {e}")
            self.connected = False
            raise

    def disconnect(self):
        """Gracefully disconnect"""
        if self.connected:
            self.logger.info(f"üëã Disconnecting from {self.name}...")
            self.protocol = None
            self.connected = False
```

**2.2 –î–æ–±–∞–≤–∏—Ç—å timeout management** (1 —á–∞—Å)
```python
# src/api/emulators.py

import asyncio
from concurrent.futures import ThreadPoolExecutor

executor = ThreadPoolExecutor(max_workers=10)

@router.post("/{emulator_id}/start")
async def start_emulator(emulator_id: str, token: str = Depends(verify_token)):
    """Start emulator with timeout"""
    try:
        # Run blocking operation in thread pool with timeout
        loop = asyncio.get_event_loop()
        result = await asyncio.wait_for(
            loop.run_in_executor(
                executor,
                lambda: server.start_emulator(emulator_id)
            ),
            timeout=30.0  # 30 second timeout
        )
        return {"status": "started", "emulator_id": emulator_id}
    
    except asyncio.TimeoutError:
        raise HTTPException(
            status_code=504,
            detail="Operation timed out after 30 seconds"
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

**2.3 –£–ª—É—á—à–∏—Ç—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ** (1 —á–∞—Å)
```python
# –î–æ–±–∞–≤–∏—Ç—å structured logging –¥–ª—è operations

logger.info("üéÆ Starting emulator", extra={
    "emulator_id": emulator_id,
    "workstation": workstation.name,
    "operation": "start",
    "timestamp": datetime.utcnow().isoformat()
})

# Log operation duration
start_time = time.time()
try:
    result = start_emulator(emulator_id)
    duration = time.time() - start_time
    logger.info(f"‚úÖ Emulator started in {duration:.2f}s", extra={
        "emulator_id": emulator_id,
        "duration_seconds": duration,
        "status": "success"
    })
except Exception as e:
    duration = time.time() - start_time
    logger.error(f"‚ùå Failed to start emulator after {duration:.2f}s", extra={
        "emulator_id": emulator_id,
        "duration_seconds": duration,
        "error": str(e),
        "status": "failed"
    })
    raise
```

**2.4 –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å** (30 –º–∏–Ω)
```python
# Server/test_stress.py
# –¢–µ—Å—Ç —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏: 10 –æ–ø–µ—Ä–∞—Ü–∏–π –ø–æ–¥—Ä—è–¥

import requests
import time

BASE_URL = "http://localhost:8000"
token = None

def login():
    global token
    response = requests.post(f"{BASE_URL}/auth/login", json={
        "username": "admin",
        "password": "admin123"
    })
    token = response.json()["access_token"]
    print("‚úÖ Logged in")

def test_operations():
    headers = {"Authorization": f"Bearer {token}"}
    
    # Get emulators
    response = requests.get(f"{BASE_URL}/api/emulators", headers=headers)
    emulators = response.json()
    print(f"‚úÖ Found {len(emulators)} emulators")
    
    if not emulators:
        print("‚ö†Ô∏è No emulators found")
        return
    
    emulator_id = emulators[0]["id"]
    
    # Stress test: Start/Stop 10 times
    for i in range(10):
        print(f"\n--- Iteration {i+1}/10 ---")
        
        # Start
        start = time.time()
        response = requests.post(
            f"{BASE_URL}/api/emulators/{emulator_id}/start",
            headers=headers
        )
        print(f"Start: {response.status_code} ({time.time()-start:.2f}s)")
        
        time.sleep(5)  # Wait for startup
        
        # Stop
        start = time.time()
        response = requests.post(
            f"{BASE_URL}/api/emulators/{emulator_id}/stop",
            headers=headers
        )
        print(f"Stop: {response.status_code} ({time.time()-start:.2f}s)")
        
        time.sleep(2)

if __name__ == "__main__":
    login()
    test_operations()
    print("\nüéâ Stress test completed!")
```

**Run:**
```powershell
python test_stress.py
```

**Success Criteria Day 2:**
- ‚úÖ Error handling —Ä–∞–±–æ—Ç–∞–µ—Ç (retry on failure)
- ‚úÖ Timeouts –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞—é—Ç –∑–∞–≤–∏—Å–∞–Ω–∏–µ
- ‚úÖ –õ–æ–≥–∏ —Å–æ–¥–µ—Ä–∂–∞—Ç –ø–æ–ª–µ–∑–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
- ‚úÖ System —Å—Ç–∞–±–∏–ª—å–Ω–∞ –ø–æ–¥ –Ω–∞–≥—Ä—É–∑–∫–æ–π (10 –æ–ø–µ—Ä–∞—Ü–∏–π)

---

### üü° DAY 3: Automated Tests - Part 1 (20 –æ–∫—Ç—è–±—Ä—è) - P1

**–í—Ä–µ–º—è:** 4-5 —á–∞—Å–æ–≤  
**–¶–µ–ª—å:** –ù–∞–ø–∏—Å–∞—Ç—å –ø–µ—Ä–≤—ã–µ 10 —Ç–µ—Å—Ç–æ–≤

#### –ó–∞–¥–∞—á–∏:

**3.1 Setup pytest –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞** (1 —á–∞—Å)
```python
# tests/conftest.py

import pytest
from fastapi.testclient import TestClient
from src.core.server_modular import app
import os

@pytest.fixture(scope="session")
def test_client():
    """Create test client"""
    return TestClient(app)

@pytest.fixture(scope="session")
def auth_token(test_client):
    """Get JWT token for authenticated requests"""
    response = test_client.post("/auth/login", json={
        "username": "admin",
        "password": "admin123"
    })
    assert response.status_code == 200
    return response.json()["access_token"]

@pytest.fixture
def auth_headers(auth_token):
    """Get authorization headers"""
    return {"Authorization": f"Bearer {auth_token}"}

@pytest.fixture(scope="session", autouse=True)
def setup_dev_mode():
    """Force DEV_MODE for tests"""
    os.environ["DEV_MODE"] = "true"
    yield
    os.environ.pop("DEV_MODE", None)
```

**3.2 Test Mock Data** (1 —á–∞—Å)
```python
# tests/test_mock_data.py

from src.utils.mock_data import (
    get_mock_emulators,
    get_mock_workstations,
    get_mock_system_status
)

def test_mock_emulators_structure():
    """Test mock emulators have correct structure"""
    emulators = get_mock_emulators()
    
    assert isinstance(emulators, list)
    assert len(emulators) == 6
    
    for emu in emulators:
        assert "id" in emu
        assert "name" in emu
        assert "status" in emu
        assert "workstation_id" in emu
        assert "config" in emu
        assert emu["status"] in ["running", "stopped"]

def test_mock_workstations_structure():
    """Test mock workstations have correct structure"""
    workstations = get_mock_workstations()
    
    assert isinstance(workstations, list)
    assert len(workstations) == 4
    
    for ws in workstations:
        assert "id" in ws
        assert "name" in ws
        assert "host" in ws
        assert "status" in ws
        assert ws["status"] in ["online", "offline"]

def test_mock_system_status():
    """Test mock system status"""
    status = get_mock_system_status()
    
    assert status["online_workstations"] == 3
    assert status["total_emulators"] == 6
    assert status["active_operations"] == 1
```

**3.3 Test Health Endpoints** (1 —á–∞—Å)
```python
# tests/test_api_health.py

def test_health_endpoint(test_client):
    """Test /api/health endpoint"""
    response = test_client.get("/api/health")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "healthy"

def test_server_status(test_client, auth_headers):
    """Test /api/status endpoint"""
    response = test_client.get("/api/status", headers=auth_headers)
    assert response.status_code == 200
    data = response.json()
    assert "status" in data
    assert "version" in data
    assert "connected_workstations" in data

def test_version_endpoint(test_client):
    """Test /api/version endpoint"""
    response = test_client.get("/api/version")
    assert response.status_code == 200
    data = response.json()
    assert "version" in data
```

**3.4 Test Authentication** (1.5 —á–∞—Å–∞)
```python
# tests/test_api_auth.py

def test_login_success(test_client):
    """Test successful login"""
    response = test_client.post("/auth/login", json={
        "username": "admin",
        "password": "admin123"
    })
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"

def test_login_invalid_credentials(test_client):
    """Test login with wrong password"""
    response = test_client.post("/auth/login", json={
        "username": "admin",
        "password": "wrong_password"
    })
    assert response.status_code == 401

def test_protected_endpoint_without_token(test_client):
    """Test accessing protected endpoint without token"""
    response = test_client.get("/api/emulators")
    assert response.status_code == 401

def test_protected_endpoint_with_invalid_token(test_client):
    """Test with invalid JWT token"""
    headers = {"Authorization": "Bearer invalid_token"}
    response = test_client.get("/api/emulators", headers=headers)
    assert response.status_code == 401
```

**3.5 Run tests** (30 –º–∏–Ω)
```bash
# Install pytest if needed
pip install pytest pytest-cov pytest-asyncio

# Run all tests
pytest tests/ -v

# With coverage
pytest tests/ -v --cov=src --cov-report=html

# Open coverage report
start htmlcov/index.html
```

**Success Criteria Day 3:**
- ‚úÖ 10+ tests written and passing
- ‚úÖ Mock data validated
- ‚úÖ Health endpoints tested
- ‚úÖ Authentication flow tested
- ‚úÖ Coverage report generated

---

### üü° DAY 4: Automated Tests - Part 2 (21 –æ–∫—Ç—è–±—Ä—è) - P1

**–í—Ä–µ–º—è:** 4-5 —á–∞—Å–æ–≤  
**–¶–µ–ª—å:** –î–æ–≤–µ—Å—Ç–∏ –¥–æ 20+ —Ç–µ—Å—Ç–æ–≤, 75% coverage

#### –ó–∞–¥–∞—á–∏:

**4.1 Test Emulator API** (2 —á–∞—Å–∞)
```python
# tests/test_api_emulators.py

def test_get_all_emulators(test_client, auth_headers):
    """Test GET /api/emulators"""
    response = test_client.get("/api/emulators", headers=auth_headers)
    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, list)
    assert len(data) >= 0

def test_get_emulator_by_id(test_client, auth_headers):
    """Test GET /api/emulators/{id}"""
    # Get first emulator
    response = test_client.get("/api/emulators", headers=auth_headers)
    emulators = response.json()
    
    if emulators:
        emu_id = emulators[0]["id"]
        response = test_client.get(f"/api/emulators/{emu_id}", headers=auth_headers)
        assert response.status_code == 200
        data = response.json()
        assert data["id"] == emu_id

def test_start_emulator(test_client, auth_headers):
    """Test POST /api/emulators/{id}/start"""
    # In DEV_MODE, this should succeed with mock
    emulators = test_client.get("/api/emulators", headers=auth_headers).json()
    
    if emulators:
        emu_id = emulators[0]["id"]
        response = test_client.post(
            f"/api/emulators/{emu_id}/start",
            headers=auth_headers
        )
        # Should return 200 or appropriate status
        assert response.status_code in [200, 202, 400]

def test_stop_emulator(test_client, auth_headers):
    """Test POST /api/emulators/{id}/stop"""
    emulators = test_client.get("/api/emulators", headers=auth_headers).json()
    
    if emulators:
        emu_id = emulators[0]["id"]
        response = test_client.post(
            f"/api/emulators/{emu_id}/stop",
            headers=auth_headers
        )
        assert response.status_code in [200, 202, 400]
```

**4.2 Test Workstation API** (1.5 —á–∞—Å–∞)
```python
# tests/test_api_workstations.py

def test_get_workstations(test_client, auth_headers):
    """Test GET /api/workstations"""
    response = test_client.get("/api/workstations", headers=auth_headers)
    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, list)

def test_get_workstation_emulators(test_client, auth_headers):
    """Test GET /api/workstations/{id}/emulators"""
    workstations = test_client.get("/api/workstations", headers=auth_headers).json()
    
    if workstations:
        ws_id = workstations[0]["id"]
        response = test_client.get(
            f"/api/workstations/{ws_id}/emulators",
            headers=auth_headers
        )
        assert response.status_code == 200
        data = response.json()
        assert isinstance(data, list)

def test_workstation_status(test_client, auth_headers):
    """Test workstation status tracking"""
    workstations = test_client.get("/api/workstations", headers=auth_headers).json()
    
    for ws in workstations:
        assert "status" in ws
        assert ws["status"] in ["online", "offline"]
```

**4.3 Integration Tests** (1 —á–∞—Å)
```python
# tests/test_integration.py

def test_full_login_to_emulator_flow(test_client):
    """Test complete flow: login ‚Üí get emulators ‚Üí get details"""
    # Step 1: Login
    response = test_client.post("/auth/login", json={
        "username": "admin",
        "password": "admin123"
    })
    assert response.status_code == 200
    token = response.json()["access_token"]
    headers = {"Authorization": f"Bearer {token}"}
    
    # Step 2: Get emulators
    response = test_client.get("/api/emulators", headers=headers)
    assert response.status_code == 200
    emulators = response.json()
    
    # Step 3: Get first emulator details
    if emulators:
        emu_id = emulators[0]["id"]
        response = test_client.get(f"/api/emulators/{emu_id}", headers=headers)
        assert response.status_code == 200

def test_error_handling_invalid_emulator_id(test_client, auth_headers):
    """Test error handling for invalid ID"""
    response = test_client.get(
        "/api/emulators/invalid-id-9999",
        headers=auth_headers
    )
    # Should return 404 or appropriate error
    assert response.status_code in [404, 400]
```

**4.4 Review Coverage** (30 –º–∏–Ω)
```bash
# Generate coverage report
pytest tests/ -v --cov=src --cov-report=html --cov-report=term

# Analyze results
# Target: 75%+ overall
# Focus on:
#   - src/api/*.py (should be 80%+)
#   - src/core/security.py (should be 90%+)
#   - src/utils/mock_data.py (should be 100%)
```

**Success Criteria Day 4:**
- ‚úÖ 20+ total tests
- ‚úÖ All emulator endpoints tested
- ‚úÖ All workstation endpoints tested
- ‚úÖ Integration flows tested
- ‚úÖ 75%+ code coverage achieved

---

### üü° DAY 5: Monitoring (22 –æ–∫—Ç—è–±—Ä—è) - P1

**–í—Ä–µ–º—è:** 4 —á–∞—Å–∞  
**–¶–µ–ª—å:** –î–æ–±–∞–≤–∏—Ç—å –±–∞–∑–æ–≤—ã–π monitoring

#### –ó–∞–¥–∞—á–∏:

**5.1 Install dependencies** (15 –º–∏–Ω)
```bash
pip install psutil prometheus-client
```

**5.2 Create monitoring module** (2 —á–∞—Å–∞)
```python
# src/utils/monitoring.py

import psutil
from datetime import datetime, timedelta
from typing import Dict, Any, List
from dataclasses import dataclass, asdict
from collections import deque

@dataclass
class MetricSnapshot:
    """Single point-in-time metric snapshot"""
    timestamp: str
    cpu_percent: float
    memory_percent: float
    disk_percent: float
    network_bytes_sent: int
    network_bytes_recv: int

class SystemMonitor:
    """Monitor system resources and health"""
    
    def __init__(self, history_size: int = 60):
        self.start_time = datetime.utcnow()
        self.history_size = history_size
        self.metric_history = deque(maxlen=history_size)
        
    def get_current_metrics(self) -> Dict[str, Any]:
        """Get current system metrics"""
        cpu_percent = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/')
        network = psutil.net_io_counters()
        
        snapshot = MetricSnapshot(
            timestamp=datetime.utcnow().isoformat(),
            cpu_percent=cpu_percent,
            memory_percent=memory.percent,
            disk_percent=disk.percent,
            network_bytes_sent=network.bytes_sent,
            network_bytes_recv=network.bytes_recv
        )
        
        self.metric_history.append(snapshot)
        
        return {
            "current": asdict(snapshot),
            "uptime_seconds": (datetime.utcnow() - self.start_time).total_seconds(),
            "cpu": {
                "percent": cpu_percent,
                "count": psutil.cpu_count(),
                "per_cpu": psutil.cpu_percent(interval=1, percpu=True)
            },
            "memory": {
                "total_gb": memory.total / (1024**3),
                "available_gb": memory.available / (1024**3),
                "used_gb": memory.used / (1024**3),
                "percent": memory.percent
            },
            "disk": {
                "total_gb": disk.total / (1024**3),
                "free_gb": disk.free / (1024**3),
                "used_gb": disk.used / (1024**3),
                "percent": disk.percent
            },
            "network": {
                "bytes_sent": network.bytes_sent,
                "bytes_recv": network.bytes_recv,
                "packets_sent": network.packets_sent,
                "packets_recv": network.packets_recv
            }
        }
    
    def get_history(self) -> List[Dict[str, Any]]:
        """Get metric history"""
        return [asdict(snapshot) for snapshot in self.metric_history]
```

**5.3 Create monitoring API** (1 —á–∞—Å)
```python
# src/api/monitoring.py

from fastapi import APIRouter, Depends
from src.core.security import verify_token
from src.utils.monitoring import SystemMonitor

router = APIRouter(prefix="/api/monitoring", tags=["monitoring"])
monitor = SystemMonitor(history_size=60)  # Keep 60 samples

@router.get("/metrics")
async def get_metrics(token: str = Depends(verify_token)):
    """Get current system metrics"""
    return monitor.get_current_metrics()

@router.get("/history")
async def get_history(token: str = Depends(verify_token)):
    """Get metric history (last 60 samples)"""
    return monitor.get_history()

@router.get("/health")
async def get_health_status(token: str = Depends(verify_token)):
    """Get health status based on metrics"""
    metrics = monitor.get_current_metrics()
    
    # Define health thresholds
    cpu_warn = 80
    memory_warn = 85
    disk_warn = 90
    
    warnings = []
    if metrics["cpu"]["percent"] > cpu_warn:
        warnings.append(f"High CPU usage: {metrics['cpu']['percent']:.1f}%")
    if metrics["memory"]["percent"] > memory_warn:
        warnings.append(f"High memory usage: {metrics['memory']['percent']:.1f}%")
    if metrics["disk"]["percent"] > disk_warn:
        warnings.append(f"High disk usage: {metrics['disk']['percent']:.1f}%")
    
    status = "healthy" if not warnings else "warning"
    
    return {
        "status": status,
        "warnings": warnings,
        "metrics": metrics["current"]
    }
```

**5.4 Add monitoring to server** (30 –º–∏–Ω)
```python
# src/core/server_modular.py

from src.api import health, auth, emulators, workstations, monitoring

# Add monitoring router
app.include_router(monitoring.router)
```

**5.5 Test monitoring** (30 –º–∏–Ω)
```python
# Server/test_monitoring.py

import requests
import time

BASE_URL = "http://localhost:8000"

# Login
response = requests.post(f"{BASE_URL}/auth/login", json={
    "username": "admin",
    "password": "admin123"
})
token = response.json()["access_token"]
headers = {"Authorization": f"Bearer {token}"}

# Get current metrics
response = requests.get(f"{BASE_URL}/api/monitoring/metrics", headers=headers)
print("üìä Current Metrics:")
print(response.json())

# Get health status
response = requests.get(f"{BASE_URL}/api/monitoring/health", headers=headers)
print("\nüíö Health Status:")
print(response.json())

# Get history (after collecting some samples)
time.sleep(10)
response = requests.get(f"{BASE_URL}/api/monitoring/history", headers=headers)
print(f"\nüìà History: {len(response.json())} samples")
```

**Success Criteria Day 5:**
- ‚úÖ Monitoring module created
- ‚úÖ API endpoints —Ä–∞–±–æ—Ç–∞—é—Ç
- ‚úÖ CPU/RAM/Disk/Network tracked
- ‚úÖ Health status calculated
- ‚úÖ Metric history available

---

## üìä WEEK 2 SUCCESS METRICS

**Must Have (P0):**
- ‚úÖ WinRM configured and tested
- ‚úÖ Server connects to real workstation
- ‚úÖ Real emulators visible in UI
- ‚úÖ Start/Stop works on real hardware

**Should Have (P1):**
- ‚úÖ 20+ automated tests written
- ‚úÖ 75%+ code coverage
- ‚úÖ Monitoring endpoints working
- ‚úÖ Health status tracking

**Could Have (P2):**
- ‚ö†Ô∏è Retry logic with exponential backoff
- ‚ö†Ô∏è Timeout management
- ‚ö†Ô∏è Circuit breakers

---

## üéâ EXPECTED OUTCOMES

**After Week 2, you will have:**

1. **Production-Ready Connections** ‚úÖ
   - Real workstation management
   - Actual emulator control
   - No mock data dependency

2. **Quality Assurance** ‚úÖ
   - 20+ automated tests
   - 75%+ code coverage
   - CI/CD ready

3. **Operational Visibility** ‚úÖ
   - System metrics tracking
   - Health monitoring
   - Performance data

4. **System Progress: 75%** ‚úÖ
   - Week 1: 50% ‚Üí Week 2: 75%
   - Ready for Week 3-4 polish
   - Pre-production state

---

## üöÄ NEXT STEPS AFTER WEEK 2

**Week 3-4 Focus:**
- Production deployment
- Performance tuning
- Advanced features (circuit breakers, graceful shutdown)
- Documentation finalization

**You're on track for production! üéØ**

---

**Created:** 17 –æ–∫—Ç—è–±—Ä—è 2025  
**Target Completion:** 22 –æ–∫—Ç—è–±—Ä—è 2025  
**Status:** üìÖ Ready to Execute
